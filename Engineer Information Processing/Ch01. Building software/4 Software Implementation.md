# 소프트웨어 구현
## 소프트웨어 개발 프레임워크
  > 개발해야할 애플리케이션 일부분이 이미 내장된 클래스 라이브러리에 구현<br>
  > 동일 로직 반복 최소화 / 재사용성 확대 / 생산성 및 유지보수성 향상
- 모듈화 / 재사용성 / 확장성 / 제어의 역흐름(프레임워크가 애플리케이션 흐름 제어)
### 스프링 프레임워크(Spring Framework)
- JAVA 플랫폼을 위한 오픈 소스 경량형 프레임워크
- 동적 웹 사이트 개발 / 전자정부 표준 프레임워크
### 전자정부 프레임워크
- 우리나라 공공부문 정보화 사업 시 효율적인 정보 시스템을 구축/지원 하기위해 필요한 기능 및 아키텍처를 제공
### 닷넷 프레임워크(.NET Framework)
- MS에서 개발한 Windows 프로그램 개발
- 공통 언어 런타임(CLR)이라는 가상 머신 상에서 작동
### API(Application Programming Interface)
- 소프트웨어 간 인터페이스(서로 다른 소프트웨어 / 서비스 간 상호 작용 용이)
- 운영체제 및 프로그래밍 언어의 기능을 프로그램에서 사용 가능하도록 구현<br>
**-> 개발 비용 저감 / 중복 작업 최소화 / 유지 관리 용이 / 비즈니스 확장**
### 팬인(Fan-In)
  > 자신을 사용하는 모듈의 수
  
  **-> 팬인이 높으면 재사용 측면 설계 우수<br>but, 단일 장애점 발생 가능성 높아 집중적인 관리 및 테스트 필요**
### 팬아웃(Fan-Out)
  > 자신이 사용하는 모듈의 수

  **-> 불필요한 호출 가능성이 있어 단순화 필요**
  ![image](https://github.com/user-attachments/assets/4acf794e-885f-443b-b68c-9359e2bf8483)
## 응집도(Cohesion)<sub>: (낮음)우논시절통순기(높음)</sub>
  > 개별 모듈이 독립적인 기능으로 정의되어 있는 정도<br>
  > 응집도⬆️ -> 품질⬆️
### 기능적(Function)
  > 모듈 내부의 모든 기능 요소가 단일 문제와 연관되어 수행
### 순차적(Sequential)
  > 모듈 내 출력 데이터를 다음 활동의 입력 데이터로 사용
### 통신적(Communication)
  > 동일한 입/출력을 사용하여 서로 다른 기능을 수행
### 절차적(Procedural)
  > 모듈 내 구성 요소들이 다수 관련 기능을 순차적으로 수행
### 시간적(Temporal)
  > 특정 시간 내 처리되는 기능을 모아 하나의 모듈로 작성
### 논리적(Logical)
  > 유사한 성격의 처리 요소들로 하나의 모듈이 형성
### 우연적(Coincidental)
  > 각 구성 요소들이 서로 관련없는 요소로만 구성
## 결합도(Coupling): (낮음)자스제외공내(높음)</sub>
  > 개별 모듈 간 상호 의존하는 정도<br>
  > 결합도⬇️ -> 품질⬆️
### 내용(Content)
  > 한 모듈이 다른 모듈의 내부 기능 및 자료를 직접 참조/수정|
### 공통/공유(Common)
  > 공유되는 공통 데이터를 여러 모듈이 사용(전역 변수 참조)|
### 외부(External)
  > 한 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조|
### 제어(Control)
  > 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈이 분리되어 설계<br>처리 대상 값 뿐만 아니라 처리 방식의 제어 요소도 전달|
### 스탬프(Stamp)
  > 두 모듈이 동일한 자료 구조(배열, 오브젝트)를 조회<br>자료 구조 및 포맷 변화시 조회하고 있는 모든 모듈에 영향|
### 자료(Data)
  > 모듈 간 인터페이스가 자료 요소로만 구성|
## 모듈의 독립성
  > 모듈간 과도한 상호 작용을 막고 하나의 독립적인 기능만을 수행

  **-> 높은 독립성 = 응집도⬆️ & 결합도⬇️**
## 객체 지향(Object-oriented)
  > 객체와 속성, 클래스와 멤버, 전체와 부분으로 나눠 분석
### 객체(Object)
  > **고유 식별자 / 하나의 독립된 존재 / 일정한 기억 장소 보유**<br>
  > **상태(state)**: 객체가 가질 수 있는 조건, 속성 값에 의한 정의<br>
  > **행위(연산, Method)**: 객체가 반응할 수 있는 메세지 집합
### 클래스(Class)
  > **공통 속성과 연산(행위)을 갖는 객체들의 집합**<br>
  > **데이터를 추상화 하는 단위**<br>
  > **인스턴스(Instance)**: 클래스에 속한 각각의 객체<br>
  > **Operation**: 클래스의 동작 / 객체에 대해 적용될 메서드를 정의
### 캡슐화(Encapsulation)
  > **데이터와 데이터 처리 함수를 하나로 묶음**<br>
  > **세부 내용은 은폐(정보 은닉)하여 외부로부터 접근을 제한**<br>
  > **결합도 낮음 / 재사용 용이 / 인터페이스 단순 / 오류 파급효과 낮음**
### 상속(Inheritance)
  > **상위 클래스의 속성과 연산을 하위 클래스가 물려받는 것**<br>
  > **다중 상속**: 단일 클래스가 두 개 이상의 상위 클래스로부터 상속
### 다형성(Polymorphism)
  > 각 객체별 고유 특성에 따라 같은 메세지임에도 여러 형태의 응답을 하는 것
### 오버라이딩(Overriding)
  > 상위 클래스로부터 상속받은 메서드를 하위 클래스에서 재정의

  **-> 단, 메서드 이름 / 매개변수 / 반환 타입은 동일**
### 오버로딩(Overloading)
  > 메서드 이름은 동일하나 매개변수 개수 또는 타입을 다르게 지정
## 객체지향 설계 5대 원칙(SOLID)
### 단일 책임 원칙(SRP, Single Reposibility Principle)
  > 모든 클래스/객체는 하나의 책임만 갖는다<br>
  > 완전한 캡슐화
### 개방 폐쇄의 원칙(OCP, Open Closed Principle)
  > 확장에는 열려있고, 수정에는 닫혀있어야 된다
### 리스코드 교체 원칙(LSP, Liskov Substitution Principle)
  > 상위 클래스의 행동 규약을 하위 클래스가 위반해서는 안된다
### 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
  > 클라이언트가 비사용 메서드에 의존하지 않아야 한다
### 의존성 역전 원칙(DIP, Dependency Inversion Principle)
  > 의존 관계 수립 시 변화하기 어려운 것(추상성이 높은 상위 클래스)에 의존해야 한다
## 아키텍처 패턴
  > **전체 시스템**의 구조를 설계
## 디자인 패턴(GoF, Gang of Four)
  > **서브 시스템에 속하는 컴포넌트들과 그 관계**를 설계하기 위한 참조 모델<br>
  > 객체 지향 프로그래밍 설계 시 자주 발생하는 문제에 대한 반복적 해결 방법
### 생성 패턴
- **Abstract Factory**<br>
  : 구체적인 클래스에 의존하지 않고, 서로 연관되거나 의존적인 객체들이 조합된 인터페이스를 제공
- **Builder**<br>
  : 객체 생성 단계를 캡슐화/분리하여 객체 생성 시 이를 조립하여 생성<br>
  -> 동일한 객체 생성 절차에서 서로 다른 표현 결과를 제공
- **Factory Method**<br>
  : 상위 클래스에서는 객체 생성 인터페이스를 정의하지만,<br>인스턴스를 만드는 클래스는 서브 클래스에서 결정하도록 분리
- **Prototype**<br>
  : 원본/원형 객체를 복제하는 방식으로 객체를 생성
- **Singleton**<br>
  : 클래스에서 하나의 객체만 생성이 가능하며,<br>해당 객체를 어디서든 참조할 수 있지만 여러 프로세스가 동시에 참조할수는 없다
### 구조 패턴
- **Adaptor**<br>
  : 비호환 인터페이스에 호환성을 부여하도록 변환
- **Bridge**<br>
  : 구현부에서 추상층을 분리 후 각자 독립적으로 변형 및 확장이 가능하도록 함
- **Composite**<br>
  : 트리 구조로 부분/전체 계층 표현, 복합/단일 객체를 구분없이 사용
- **Decorator**<br>
  : 상속 상용없이 객체 간 결합을 통해 객체 기능을 동적으로 추가/확장
- **Facade**<br>
  : 상위에 인터페이스를 구성하여 서브 클래스의 기능을 복잡하게 표현하지 않고 단순한 인터페이스로 구현
- **Flyweight**<br>
  : 인스턴스를 공유하여 메모리를 절약 -> **클래스 경량화**
- **Proxy**<br>
  : 접근이 힘든 객체를 연결하는 인터페이스 역할 -> **대리 객체 수행**
### 행위 패턴
- **Chain of Responsibility**<br>
  : 처리 가능한 객체가 둘 이상 존재하여 한 객체 내 처리가 불가할 시 다음 객체로 이관하여 처리
- **Command**<br>
  : 요청 명령어들을 추상/구체 클래스로 분리한 후 단순화/캡슐화하여 사용
- **Interpreter**<br>
  : 언어에 문법 표현을 정의
- **Iterator**<br>
  : 접근이 빈번한 객체에 대해 동일 인터페이스를 사용
- **Mediator**<br>
  : 객체들간 복잡한 상호작용을 캡슐화하여 객체로 정의 후 중재
- **Memento**<br>
  : 객체를 이전의 특정 시점의 상태로 저장하고 복원 (캡슐화 유지)
- **Observer**<br>
  : 한 객체 상태 변화시 상속되어 있는 객체들에게 변화를 전달
- **State**<br>
  : 객체의 상태에 따라 동일한 동작을 다르게 처리
- **Strategy**<br>
  : 동일 계열 알고리즘을 개별적으로 캡슐화하여 상호 교화
- **Template Method**<br>
  : 여러 클래스에서 공통 사용 메서드를 상위 클래스에서 정의하고, 하위 클래스마다 다르게 구현해야 하는 세부 사항을 개별적으로 구현
- **Visitor**<br>
  : 각 클래스 데이터 구조로부터 처리/연산 기능을 분리하여 별도의 클래스를 만들고, 해당 클래스 메서드가 각 클래스를 돌아다니며 특정 작업을 수행 -> **객체 구조 변경 X / 새로운 연산 기능만 추가**
