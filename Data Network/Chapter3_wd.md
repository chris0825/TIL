# 3.4 신뢰적인 데이터 전송의 원리
### 신뢰적인 데이터 전송 프로토콜(Reliable data transfer protocol)
  - 신뢰적인 채널에서는 전송된 데이터가 손상되거나 손실되지 않는다
  - 모든 데이터는 전송된 순서 그대로 전송된다
### 단방향 데이터 전송(Unidirectional data transfer)
  - 송신측으로 부터 수신 측까지의 데이터 전송만을 고려
### 양방향(전이중) 데이터 전송(Bidirectional data transfer)
  - rdt의 송신 측과 수신 측은 전송 데이터를 포함하는 패킷을 교환하는 것 외에 제어 패킷을 양쪽으로 전송해야 한다
  - rdt의 송신 측과 수신 측 모두 udt_send()를 호출함으로써 다른 쪽에 패킷을 전송한다
    ㄴ UDT는 비신뢰적인 데이터 전송(Unreliable data transfer)

## > rdt1.0: 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송
### 유한상태 머신(FSM, Finite-state machine)
  - 송/수신자에 대해 분리된 FSM존재

## > rdt2.0: 비트 오류가 있는 채널상에서의 신뢰적 데이터 전송
### 긍정 확인응답(ACK, Positive Acknowledgment, OK)
  - 일반 시나리오에서 메시지 수신자는 각각의 문장을 듣고 이해하고 기록한 후에 OK라고 말함
### 부정 확인응답(NAK, Negative Acknowledgment, 그것을 반복해주세요)
  - 문장을 올바르게 듣지 못했다면 반복하라고 요청함
  - 같은 패킷에 대해 2개의 ACK(중복 ACK 수신)을 수신한 송신자는 수신자가 두번 ACK한 패킷의 다음 패킷을 정확하게 수신하지 못했다고 인지
    - 중복ACK = NAK
### 자동 재전송 요구(ARQ, Automatic Repeat reQuest)
  - 정확하게 수신되었는지 또는 잘못 수신되어 반복이 필요한지를 수신자가 송신자에게 알려주어 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜
### 오류 검출
: 비트 오류가 발생했을 때 수신자가 검출할 수 있는 기능
### 수신자 피드백
: 긍정 확인응답(ACK), 부정 확인응답(NAK)
### 재전송
: 오류를 가지고 수신된 패킷은 송신자에 의해 재전송
### 전송 후 대기(Stop-and-Wait)
  - 송신자는 수신자가 현재의 패킷을 정확하게 수신했음을 확신하기 전까지 새로운 데이터를 전달하지 않음
### 중복 패킷(Duplicate packet)
  - 송신자가 왜곡된 ACK/NAK 패킷을 수신할 때 현재 데이터 패킷을 단순히 다시 송신하는 것
### 순서 번호(Sequence number)
  - 데이터 패킷에 송신자가 번호를 붙임
  - 수신자는 수신된 패킷이 재전송인지를 결정할 때 순서 번호만 확인하면 됨

## > rdt3.0: 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송
### 카운트다운 타이머(Countdown Timer)
  - 매 패킷이 송신된 시간에 타이머 시작
  - ACK or NAK 수신 / 아무것도 수신받지 않음
  - 타이머 종료
### 얼터네이팅 비트 프로토콜(Alternating-bit Protocol)
  - 패킷의 순서 번호가 0과 1이 번갈아 나타남
### 이용률 (또는 효율, Utilization)
### 유효 처리량(Effective Throughput)
### 파이프라이닝(Pipelining)
  - 확인 응답들(ACK/NAK)을 기다리기 전에 송신자가 N개의 패킷을 전송하도록 허용한다면 송신자의 이용률은 N배가 됨
### N부터 반복(GBN, Go-Back-N)
  - 확인 응답을 기다리지 않고 여러 패킷을 전송
  ### 윈도 크기(Window size)
    - 순서번호 공간에서 응답 없이 전송 받을 수 있는 크기
  ### 슬라이딩 윈도 프로토콜(Sliding-Window Protocol)
    - 순서번호 순으로 응답이 완료되면 응답이 된 만큼 순서번호 공간에서 오른쪽으로 밀림
  ### 누적 확인응답(Cumulative Acknowledgment)
    - N까지 순서 번호를 가진 모든 패킷이 정상 수신 되면 N까지에 대한 확인 응답 전송
  ### 이벤트 기반 프로그래밍(Event-Based Programming)
    - 다양한 이벤트에 대한 대응으로 취할 수 있는 동작 구현
### 선택적 반복(SR, Selective Repeat)
  - 수신자에서 오류가 발생한 패킷을 수신했따고 의심되는 패킷만을 송신자가 재전송
  - 각각의 개별적인 재전송은 수신자가 올바르게 수신된 패킷에 대한 개별적인 확인 응답 요구

# 3.5 TCP: 연결 지향형 트랜스포트
### 연결지향형(Connection-Oriented)
  - 애플리케이션 프로세스가 데이터를 다른 프로세스에게 보내기 전에, 두 프로세스가 서로 '핸드 셰이크'를 먼저 해야함
### 전이중 서비스(Full-Duplex Service)
  - 애플리케이션 계층 데이터는 A, B동시에 흐를 수 있음
### 점대점(Point-to-Point)
  - 단일 송신자와 단일 수신자
### 클라이언트/서버 프로세스 (Client/Server Process)
  - 클라이언트 프로세스 = 연결을 초기화하는 프로세스
  - 서버 프로세스 = 다른 프로세스
### 세 방향 핸드셰이크(Three-way Handshake)
  - 두 호스트 사이에 3개의 세그먼트가 오감
### 송신 버퍼(Send Buffer)
### 최대 세그먼트 크기(MSS, Maximum Segment Size)
  - 세그먼트로 모아 담을 수 있는 최대 데이터 양
### TCP 세그먼트(TCP Segment)
  - TCP헤더 + 클라이언트 데이터

### > TCP 세그먼트 헤더를 구성하는 필드
**- 출발지와 목적지 포트 번호(Source and Destination Port Number)**
  > 상위 계층 애플리케이션으로부터 다중화와 역다중화를 하는 데 사용

**- 체크섬 필드(Checksum Field)**

**- 순서 번호 필드(Sequence Number Field)**

**- 확인응답 번호 필드(Acknowledgement Number Field)**

**- 수신 윈도(Receive Window)**

**- 헤더 길이 필드(Header Length Field)**

**- 옵션 필드(Option Field)**

**- 플래그 필드(Flag Field)**

  - ACK 비트
    > 성공적으로 수신된 세그먼트에 대한 확인응답 포함
  - RST, SYN, FIN 비트
    > 연결 설정/해제에 사용
  - PSH 비트
    > 수신자가 데이터를 상위 계층에 즉시 전달해야함을 가리킴
  - URG 비트
    > 이 세그먼트에서 송신 측 상위 계층 개체가 '긴급'으로 표시하는 데이터임을 지칭
    > 긴급 데이터 포인터 필드(Urgent Data Pointer Field)에 의해 가리켜짐
  
### 누적 확인응답(Cumulative Acknowledgment)
  - 첫번째 잃어버린 바이트까지의 바이트들까지만 확인응답
### 피기백(Piggybacked)
  - 클라이언트가 수신하는 서버에게 데이터에 대한 확인응답을 제공할 때, 데이터 세그먼트 안에 확인응답을 포함해 간다.(업어간다 = 피기백된다)
### 지수적 가중 이동 평균(EWMA, Exponential Weighted Moving Average)
  - 예전 샘플보다 최근 샘플에 높은 가중치를 부여함
  - 최신 샘플들이 네트워크 상의 현재 혼잡을 더 잘 반영함
### 신뢰적 데이터 전송 서비스(Reliable Data Transfer Service)
  - 프로세스가 자신의 수신 버퍼로부터 읽은 데이터 스트림이 손상되지 않았으며 손실이나 중복이 없다는 것과 순서가 유지된다는것을 보장한다.
### 빠른 재전송(Fast Retransmit)
  - 세그먼트의 타이머가 만료되기 이전에 손실 세그먼트를 재전송 하는것을 의미
### 선택적 확인응답(Selective Acknowledgment)
  - TCP수신자가 마지막으로 올바로 수신된 순서가 맞는 세그먼트에 대해 누적 확인응답을 하기 보다는 순서가 틀린 세그먼트에 대해 선택적으로 확인응답을 하게 함
### 흐름 제어 서비스(Flow-Control Service)
  - 송신자가 수신자의 버퍼를 오버플로시키는 것을 방지하기 위함
### 혼잡 제어(Congestion Control)
  - IP 네트워크에서 혼잡때문에 억제함
### 수신 윈도(Receive Window)
  - 수신 측에서 가용한 버퍼 공간이 얼마나 되는지 송신자에게 알려줌
### SYN 플러드 공격(SYN flood attack)
  - 공격자는 핸드셰이크의 세번째 단계를 완료하지 않은 상태에서 무수한 TCP SYN 세그먼트를 보낸다.
  - TCP SYN 세그먼트의 대홍수로 서버의 연결 자원이 반쪽 연결에 할당되지만 전혀 사용되지 않는다.
  - 결국 서버의 연결 자원이 소진됨에 따라 합법적인 클라이언트들의 서비스가 거부된다.
### SYNACK 세그먼트(STNACK segment)
  - 연결 승인 세그먼트
### SYN 쿠키
  - 그 세그먼트가 정당한 사용자로부터 온 것인지 SYN플러드 공격의 한 부분인지 알 수 없다.
  - 오직 자신만 아는 비밀번호뿐만 아니라 SYN 세그먼트의 출발지와 목적지 IP주소들과 포트 번호들의 복잡한 함수로 초기 TCP 순서번호를 만든다.
  - 합법적인 클라이언트는 ACK 세그먼트를 회신하지만, 가짜 클라이언트는 ACK을 회신하지 않아 SYN에 대해 어떤 자원도 할당하지 않았으므로 처음의 SYN은 서버에 해를 끼치지 못한다.

## 3.6 혼잡 제어의 원리
### 연결당 처리량(Per-Connection Throughput)
**패킷 도착률이 링크 용량에 근접함에 따라 큐잉 지연이 커진다**

## 송신율(Sending Rate)
## 제공된 부하(Offered Load)
**송신자는 버퍼 오버플로 때무에 버려진 패킷을 보상하기 위해 재전송을 수행한다**

**커다란 지연으로 인한 송신자의 불필요한 재전송은 라이터가 패킷의 불필요한 복사본들을 전송하는 데 링크 대역폭을 사용하는 원인이 된다**

**혼잡 때문에 패킷이 경로상에서 버려질 때, 버려지는 지점까지 패킷을 전송하는 데 사용된 상위 라우터에서 사용된 전송 용량은 낭비된 것이다**

### 종단 간의 혼잡 제어
### 네트워크 지원 혼잡 제어
### ATM ABR(Available Bite Rate)

## 3.7 TCP 혼잡 제어
### 혼잡 윈도(Congestion Window)
**송신자의 송신 속도는 대략 swnd/RTT바이트/초이다.**

**cwnd의 값을 조절하여, 송신자는 링크에 데이터를 전송하는 속도를 조절할 수 있다**

### 자체 클로킹(Self-Clocking)
  - TCP는 확인 응답을 혼잡 위도 크기의 증가를 유발하는 트리거 또는 클록으로 사용하므로 TCP는 자체 클로킹이라고 함
**손실된 세그먼트는 손실을 의미**

**TCP전송률은 한 세그먼트를 손실했을 떄 줄여야 한다**

**확인응답된 세그먼트는 네트워크가 송신자의 세그먼트를 수신자에게 전송된다는 것이고, 이에 따라 이전에 확인응답되지 않은 세그먼트에 대해 ACK가 도착하면 송신자의 전송률은 증가할 수 있다**

### TCP 혼잡 제어 알고리즘(TCP Congestion-control Algorithm)
  1. 슬로 스타트(Slow Start): 1 MSS에서 시작하여 전송 세그먼트가 첫 번째로 확인응답을 받을 때 마다 1 MSS씩 증가 (1 > 2 > 4 > 8 ... 지수적으로 증가)
      - 지수적 증가가 종료되는 지점
        1. 타임아웃으로 표시되는 손실 이벤트가 있을 경우
          > cwnd값을 1로 설정하고 새로운 슬로 스타트 시작하고 슬로 스타트 임곗값(ssthresh, Slow Start Threshold)의 값을 cwnd/2로 정함
        2. ssthresh값에 도달하거나 지나칠 경우
          > TCP 혼잡 회피모드 전환하여 cwnd를 좀 더 조심스럽게 증가
        3. 3개의 중복 ACK검출
          > 빠른 재전송을 수행하여 빠른 회복상태로 전환
  2. 혼잡 회피(Congestion Avoidance)
    - cwnd의 값은 혼잡이 발생한 마지막 시점에서의 값의 절반으로 설정
    - RTT마다 하나의 MSS만큼 cwnd증가
  3. 빠른 회복(Fast Recovery)
    - cwnd값을 손실된 세그먼트에 대해 수신된 모든 중복된 ACK에 대해 1 MSS만큼 증가
    - cwnd값은 1 MSS로 하고, ssthresh값은 손실 이벤트가 발생할 떄의 cwnd값의 반으로 
### TCP 분할
  - 프론트엔드 서버에서 TCP 연결을 나누는 것을 의미
### TCP 타호(TCP Tahoe)
  - 초기 TCP 버전
  - 타임아웃으로 표시되거나, 3개의 중복 ACK으로 표시되는 손실이 발생하면 무조건 혼잡 윈도를 1MSS로 줄이고, 슬로 스타트 단계로 들어간다.
### TCP 리노(TCP Reno)
  - 새로운 TCP 버전
  - 빠른 회복이 특징
### 가법적 증가, 승법적 감소(AIMD, Additive-Increase, Multiplicative Decrease)
  - 가법적 증가: TCP의 혼잡 제어는 RTT마다 1 MSS씩 cwnd의 선형(가법적인)증가
  - 승법적 감소: 3개의 중복 ACK 이벤트에서 cwnd의 절반화(승법적 감소)로 구성
### TCP 큐빅(TCP CUBIC)
  - TCP 리노와 스타트 단계와 빠른 복구 단계는 동일하지만, 혼잡 회피 단계에서 차이점이 존재
  1. 처음 손실이 감지되면 윈도크기를 W_max로 함
  2. 이후 전송 속도를 반감함(승법적 감소)
  3. 리노의 경우 선형증가(가법적 증가)하지만, 큐빅의 경우 세제곱함수로 증가시킴
  4. W_max에 전송속도가 가까워지면 조심스럽게 탐지
  5. 조심스럼게 탐지하던 과정에서 전송 속도가 W_max를 넘었음에도 손실이 발생하지 않는다면 손실을 유발하던 링크의 정체수준이 크게 변경된 것으로 인지하고 다시 전송속도를 급격하게 증가시킴
### 명시적 혼잡 알림(ECN, Explicit Congestion Notification)
  - 인터넷 내에서 수행되는 네트워크 지원 혼잡 제어의 한 형태
  - ECN비트의 한 설정을 라우터 정체를 파악할 수 있는 비트로 사용되어 송신자에게 ACK을 보낼 때 Echo비트를 설정하여 라우터 혼잡 상태를 명시하여 TCP송신자가 빠른 재전송을 사용하여 혼잡윈도를 절반으로 줄여 혼잡 알림 표시가 있는 ACK에 반응한다
### 명시적 혼잡 알림 에코(ECE, Explicit Congestino Notification Echo)
### CWR(Congestion Window Reduced) 비트
  - 혼잡 윈도를 줄이면 해당 비트를 1로 설정
### 데이터그램 혼잡 제어 프로토콜(DCCP, Datagram Congestion Control Protocol)
  - ECN을 활용하여 적은 오버헤드, 혼잡 제어되는 UDP와 같은 신뢰할 수 없는 서비스를 제공
### 데이터 센터 TCP(DCTCP, Data Center TCP)
  - 데이터 센터 네트워크 전용으로 설계
### 데이터 센터 정량화된 혼잡 알림(DCQCN, Data Center Quantized Congestion Notification)
  - ECN을 사용
### TCP 베가스(TCP Vegas)
  - 패킷 손실 이전에 더 일찍 전송 속도를 줄일 수 있으면 값비싼 패킷 손실 및 재전송을 피할 수 있게 되므로 손실 발생 전 혼잡 시작을 사전에 감지하기 위해 TCP 베가스를 개발
  1. 모든 확인응답된 패킷에 대한 출발지에서 목적지까지 경로의 RTT를 측정
  2. 실제 송신자가 측정한 처리량이 이 값에 가까우면 경로가 아직 정체되지 않았다고 인지
  3. 따라서 TCP 전송 속도가 증가할 수 있다고 판단
  4. 그러나 실제 송신자가 측정한 처리량이 혼잡하지 않을 때의 처리율보다 현저히 낮으면 경로가 혼잡하다고 인지
  5. TCP 베가스 송신자는 전송 속도 낮춤
  - RTT_min(= 경로가 정체되지 않고 패킷이 최소 대기 지연을 겪은 시간 = RTT 측정값 중 최솟값), cwnd(= TCP 베가스의 혼잡 윈도 크기), cwnd/RTT_min(= 혼잡하지 않을 때 처리율)
**파이프를 가득 채우되 그 이상으로 채우지 않도록 해야한다**

### 병목 링크(Bottleneck Link)
  - 각 연결에 대해 연결 경로상에 있는 모든 링크는 혼잡하지 않고 병목 링크의 전송 용량과 비교해서 충분한 전송 용량을 갖고있음을 의미
## 3.8 트랜스포트 계층 기능의 발전
### 빠른 UDP 인터넷 연결(QUIC, Quick UDP Internet Connections)
  - 두 종단 사이에 신뢰적이고 혼잡 제어된 데이터 전송을 제공하는 애플리케이션 계층 프로토콜이다
  1. 연결지향적이고 안전함
    > 연결상태를 설정하기 위해 필요한 종단 간에 핸드셰이크와 인증 및 암호화에 필요한 핸드셰이크를 결합
  2. 스트림
    > 2개의 QUIC 종단 간에 데이터를 순서대로 안정적으로 전달하기 위한 추상화
  3. 신뢰적이고 TCP 친화적인 혼잡 제어 데이터 전송
