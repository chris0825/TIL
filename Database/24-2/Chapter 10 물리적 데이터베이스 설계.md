# 물리적 데이터베이스 설계
- 논리적 데이터 구조를 물리적 데이터 모델로 사상
- 예상 접근 빈도를 고려하기 위해 데이터베이스 질의와 트랜잭션 분석
- 데이터에 대한 효율적 접근을 위해 저장 구조와 접근 방법들을 다룸
- 특정 DBMS 특성을 고려하여 진행
- 효율적으로 질의를 지원하기 위해 인덱스 구조를 적절히 사용

# 보조기억 장치
- 데이터 검색시, 데이터를 포함하고 있는 블록을 읽어 주기억장치로 가져옴
- 데이터 변경시, 블록들을 디스크에 다시 기록
- 블록의 크기는 512Byte ~ 다양함(보통 4MB)
- 각 파일은 고정된 크기의 블록들로 나누어져 저장
- 대표적 보조기억장치: 디스크

# 자가디스크
- 주기억장치와 디스크간 이동 = 블록단위로 수행
- 블록은 1개 이상의 섹터로 구성
## 디스크 접근시간
  ```text
  = 탐색시간 (원하는 실린더 위에 디스크 헤드가 놓이는 시간)
  + 회전 지연시간 (원하는 블록이 헤드에 접근하는 시간)
  + 블록 전송시간 (블록을 주기억장치로 전송하는 시간(블록의 크기와 버스 시간에 따라 상이함))
  ```
### 읽기나 쓰기 과정에서 대부분의 시간을 차지하는 것
- 탐색시간
- 회전 지연시간

➡️ 이중버퍼링으로 시간 단축 가능
### 접근(탐색) 성능
- 순차접근 > 임의접근
## 물리적 디스크 블록 주소의 구성
- 표면번호
- 표면 내 트랙번호
- 트랙 내 블록번호

## DBMS와 자가디스크
- DBMS는 가능한한 연관된 레코드를 다음과 같은 순서대로 저장함
  1. 동일 블록
  2. 동일 트랙
  3. 동일 실린더
  4. 인접 실린더
- 브록들이 인접해 있을 필요는 없으나, 인접해 있으면 입출력 속도 향상(하드웨어 특성)
### 디스크상 파일 레코드 배치
- 연관 필드가 모여 파일 고정(가변)길이 레코드가 됨
- 필드 ⊆ 레코드 ⊆ 블록 ⊆ 파일
## DBMS의 성능
> 디스크 입출력 연산 횟수와 반비례<br>
> (∵ CPU 성능 >>> 디스크 속도)

# 버퍼
- 디스크 브록들을 저장하는데 사용되는 주기억장치 공간
- LRU(오래된 페이지 버림) 알고리즘으로 버퍼 관리
## 데이터 읽고 쓰기
- 데이터 읽기
  > DBMS -> 디스크 -> 버퍼 -> 응용프로그램
- 데이터 쓰기(갱신)
  > DBMS -> 버퍼 -> 디스크
### 디스크 입출력 횟수와 DBMS성능은 반비례
> 가능한 많은 블록 또는 자주 참조되는 블록을 주기억장치에 유지

# 레코드
- 데이터는 일반적으로 레코드 형태로 저장됨
- 각 레코드는 연관된 데이터 값이나 항목들로 구성
- 각 값은 하나 이상의 바이트로 구성되며 레코드 특정 필드에 해당
## 레코드 타입
### BLOB
> 이미지, 비디오 등 대규모 비구조적 개체는 별도 디스크 블럭들의 풀에 저장하고 레코드에는 그 포인터를 제공
### 고정길이 레코드
> 레코드 길이가 n바이트라고 가정,<br>
> 레코드 i에 접근하기 위해서는 n X (i - 1) + 1위치를 읽음
### 가변길이 레코드
- 레코드 구분 방식
  1. 분리 문자 사용
  2. 바이트 길이 기록
- 레코드 삭제 후 해당 위치보다 더 긴 길이의 레코드를 삽입하려면 다른 레코드들의 위치를 옮겨 공간을 추가 확보해야 함
## 레코드 블로킹
> 블록 크기가 레코드 크기보다 큰 경우 블록 안에 여러 레코드를 저장
- 블로킹 인수
  > 블록의 남은 크기가 레코드 크기보다 작아 사용되지 않는 공간<br>
  > ➡️ 해당 공간만큼 일부만 저장하고 나머지는 다른 블록에 저장

## 신장/비신장 레코드
### 신장 조직
> 레코드를 하나 이상의 블록에 걸쳐 저장하는 방식
> 레코드 하나의 크기가 한 블록의 크기보다 큰 경우 사용(∵ 블록단위 데이터 전송)
### 비신장 조직
> 레코드가 블록 경계를 넘지 않도록 저장
### 평균 레코드 크기가 큰 경우 각 블록 내 손실을 줄이기 위해 신장 조직 사용이 유리

# 파일 조직
- 기억장치상 레코드와 블록들을 저장하고 서로 연결시키는 방법
- 접근 방법은 파일에 적용할 수 있는 연산들의 그룹을 제공
- 자주 사용되는 연산들이 효율적으로 수행될수록 성능이 우수
## 유형
1. [비순차(하프, Heap) 파일](#비순차하프-heap-파일)
2. [순차 파일](#순차-파일)
3. [인덱스된 순차 파일](#인덱스된-순차-파일)
4. 직접 파일
### 비순차(하프, Heap) 파일
- 특징
  - 가장 단순한 파일 조직
  - 레코드 삽입 순서대로 파일에 저장
  - 레코드 검색
    > 모든 레코드 순차 검색
  - 특정 레코드 삭제
    > 검색 후 삭제(삭제한 공간 비워둠)<br>
    > 성능 유지를 위해 주기적 파일 재조직 필요
- 장점
  > 레코드 접근 순서가 중요하지 않은 연산(모든 레코드 참조 등), 삽입 질의
- 단점
  > 특정 레코드 접근 질의
### 순차 파일
- 레코드의 탐색키<sub>(= 파일정렬에 사용되는 필드)</sub> 값의 순서에 따라 저장된 파일
- 레코드 삭제
  > 삭제한 공간 비워둠<br>
  > 성능 유지를 위해 주기적 파일 재조직 필요
- 장점
  > 탐색키를 이용한 검색 질의<br>
  > (∵ 탐색키 검색시 이진 검색 수행: log<sub>2</sub>N)
- 단점
  > 삽입 연산 및 모든 레코드 접근 질의
### 인덱스된 순차 파일
- 탐색 조건에 따라 레코드들을 빠르게 검색하기 위해 사용되는 별도 보조 파일
  > 인덱스 파일은 본 파일과 별도의 파일로 저장

# 인덱스
## 장단점
### 장점
- 검색 속도 향상
- 릴레이션 크기가 클 수록 성능 차이
- 릴레이션 중 일부만 검색하는 경우
- WHERE절이 잘 표현된 경우
### 단점
- 삽입, 삭제, 수정 연산
  > but, 소수의 레코드 수정/삭제 연산에서는 장점
- 별도 인덱스 저장공간 필요
## 구성
> 탐색키, 레코드 포인터(주소값)
- 파일의 필드 단위로 인덱스를 정의
- 데이터 파일에 비해 훨씬 작음
- 한 파일에 여러 인덱스 저장이 가능
- 검색하려는 레코드가 위치한 하나 또는 여러 블록의 주소를 제공
## 인덱스 엔트리
- 탐색키 오름차순 정렬(이진 검색)
- 탐색키는 아무 애트리뷰트나 가능(유일성 만족 필요 X)
## 밀집 인덱스 VS 희소(비밀집) 인덱스
### 밀집 인덱스
> 모든 레코드마다 엔트리를 유지
### 희소(비밀집) 인덱스
> 각 데이터 블록마다 엔트리를 유지
## 기본 인덱스
- 탐색키 = 기본키
- 순차 파일
  > 탐색키(기본키)에 따라 정렬
- 희소 인덱스
  > 블록 단위 엔트리<br>
  > 블록앵커: 각 블록의 시작(or 끝) 레코드의 필드 값을 엔트리로 가짐
![기본 인덱스](https://github.com/chris0825/TIL/blob/main/Database/resource/%EA%B8%B0%EB%B3%B8%20%EC%9D%B8%EB%8D%B1%EC%8A%A4.PNG?raw=true)
## 클러스터링 인덱스
- 탐색키(≠ 기본키)
- 순차 파일
  > 탐색키에 따라 정렬
- 희소 인덱스
![클러스터링 인덱스1](https://github.com/chris0825/TIL/blob/main/Database/resource/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%20%EC%9D%B8%EB%8D%B1%EC%8A%A4.PNG?raw=true)
![클러스터링 인덱스2](https://github.com/chris0825/TIL/blob/main/Database/resource/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%20%EC%9D%B8%EB%8D%B1%EC%8A%A42.PNG?raw=true)
## 보조 인덱스
- 이미 인덱스가 존재하지만, 다른 정렬이 필요한 경우 사용
  > 탐색키로 이미 정렬되어 있지만 다른 정렬이 필요한 경우<br>
  > 파일은 최대 1개의 필드에 대해서만 정렬되어 저장
- 후보키나 유일정을 만족하는 애트리뷰트 선택
- 밀집 인덱스
  > 직접 레코드 포인터를 갖거나, 간접적으로 블록 포인터를 갖고, 해당 블록 인덱스에서 레코드 포인터를 가짐
## 다단계 인덱스
- 인덱스를 여러 단계로 나눔
  > ∵ 인덱스 자체가 큰 경우 탐색 시간이 오래 걸림
- 마스터 인덱스
  > 다단계 인덱스에서 최상위 단계의 인덱스<br>
  > 한 블록으로 이루어져 주기억장치에 상주
- 탐색 트리
  > 주로 B<sup>+</sup>-트리 형태<br>
  > 새로운 인덱스 삽입 삭제가 매우 복잡
![다단계 인덱스](https://github.com/chris0825/TIL/blob/main/Database/resource/%EB%8B%A4%EB%8B%A8%EA%B3%84%20%EC%9D%B8%EB%8D%B1%EC%8A%A4.PNG?raw=true)
## SQL 인덱스 정의문
- PRIMARY KEY
  > 기본인덱스 생성
- UNIQUE 제약조건
  > 보조 인덱스 생성
- CREATE INDEX문
  > 자동으로 생성되는 인덱스 외 추가 인덱스 생성
  > 2개 이상의 애트리뷰트 조합으로도 생성 가능
### 인덱스가 사용되지 않은 경우
1. WHERE절에 인덱스 애트리뷰트에 산술 연산자를 사용한 경우
2. DBMS 내장함수를 사용하는 경우
3. NULL에 대한 질의
4. UNIQUE하지 않은 속성에 대한 범위(동등)질의
### 인덱스 생성 가이드라인
- 생성 가이드라인
  1. 자주 조회되는 애트리뷰트
  2. 검색하는 투플이 소수(전체의 15%미만)인 경우
  3. 조인에 사용되는 애트리뷰트
  4. 정수형 애트리뷰트
  5. 복합 인덱스의 경우 질의에 구성된 순서대로
  6. 대량의 데이터 삽입시 기존 인덱스 제거 후 데이터 삽입이 끝난 후 재생성
- 인덱스 생성 지양
  1. 자주 갱신되는 애트리뷰트
  2. 갱신이 빈번한 릴레이션
  3. 가변길이(VARCHAR) 애트리뷰트
  4. 레코드 수가 적은 릴레이션
