### 공유 데이터 일관성(Consistency)
  - 일관성 문제가 발생하는 이유
    1. 여러 프로세스가 동시에 공유 데이터에 접근하는 경우
    2. 한 프로세스가 데이터를 수정중에 다른 프로세스가 동일한 데이터에 접근하는 경우
    3. 프로세스간 동기화가 제대로 이루어 지지 않은 경우 수정된 내용이 다른 프로세스가 동일 데이터 접근 시 반영 안됨
    4. 캐시 활용시 데이터에 저장된 내용이 최초 캐시에 저장된 내용과 달라져 메모리에 반영되는 과정에서 문제 발생
  - 프로세스들이 실행되는 순서에 따라 결과가 달라질 수 있어 프로세스들 간 실행 순서를 적절히 유지하여 데이터의 일관성을 유지하기 위해 동기화 처리가 필요함
### 크리티컬 섹션
  - 프로그램에서 프로세스들 간 공유 데이터를 사용하는 코드 부분을 의미
  - 여러 프로세스가 동시에 접근하면 크리티컬 섹션 문제 발생
### Entry/Exit 섹션
  - 공유 변수와 관련된 다른 프로세스의 크리티컬 섹션이 실행중에 있는지 검사하여 실행중이라면 끝날 때 까지 기다린다.
  - 구현 조건
    - 상호 배제: 한 프로세스가 공유데이터와 관련된 크리티컬 섹션을 실행중이면 다른 프로세스는 실행 금지
    - 진행: 아무 프로세스도 크리티컬 섹션을 실행하고 있지 않을 때  크리티컬 섹션을 실행하고자 하는 프로세스중 하나는 크리티컬 섹션을 실행할 수 있어야 한다
    - 제한된 대기시간: 일정한 시간 이내에 자신의 크리티컬 섹션을 실행할 수 있어야 한다
### 인터럽트 금지를 이용한 해법
  - 단일 프로레서 시스템에서만 적용 가능
  - 아주 간단하게 구현 가능
  - 문맥교환 방지
    - entry 섹션 부분에 인터럽트 금지 명령어를, exit 섹션에 인터럽트 허용 명령어를 사용
  - 사용 제한
    - 크리티컬 섹션을 실행 중에는 문맥 교환이 발생할 수 있는 시스템 콜 함수 호출 금지
### 스핀락
  - 상호배제를 위해 사용할 수 있도록 구현한 것
  - 비지웨이팅(Busy Waiting)
    - CPU자원 낭비 가능성
    - 한 프로세스가 비지웨이팅 중이면 다른 프로세스는 실행기회 박탈
  - 단일 프로세서 시스템에 적합하지 않음
  - 멀티 프로세서 시스템에 상호배제에 유용하게 사용 가능
  - 긴 실행시간이 필요한 크리티컬 섹션에는 적합하지 않음
  - 사용자 프로세스에서 직접 사용 불가
### 뮤텍스(Mutex)
  - 프로세스에서 직접 사용할 수 있도록 운영체제가 제공하는 기능
  - 비지웨이팅 방식이 아닌 lock함수에서 조건이 만족되지 않으면 호출한 프로세스 waiting상태로 전환
  - unlock 함수에서는 waiting상태의 프로세스 모두 깨움(동작 과정의 효율을 위해 하나만 선택하여 ready상태로 전환하기도 함)
  - 위 과정들은 크리티컬 섹션으로 처리(커널의 중요한 공유 데이터들을 수정하는 작업이 수반되고 중간에 인터럽트 처리나 다른 CPU의 실행에 의해 이 데이터들이 사용될 수 있기 때문)
  - 커널에서 구현
  - 시스템 콜 함수 형태로 제공
  - lock을 통과한 프로세스를 이 뮤텍스의 소유자로 기록
  - 스핀락과 차이
    - 스핀락의 경우 비지웨이팅을 하면서 수시로 자원 사용 가능 여부를 파악하지만 뮤텍스의 경우 unlock함수가 호출되면서 waiting상태에 있는 프로세스들을 ready상태로 전한
### 세마포(Semaphore)
  - 정수값을 가지며 wait, signal 두 가지의 동작만 적용
  - wait동작: 현재의 정수 값이 양수가 될 때까지 기다렸다가 값을 1만큼 줄임
  - signal동작: 정수값 1만큼 증가
  - 크리티컬 섹션 문제에 활용하려면 초기값을 1로 설정하고 entry섹션에 wait, eixt섹션에 signal사용하면 됨
  - 뮤텍스와의 차이
    - 뮤텍스는 lock함수 조건 만족 또는 불만족을 고려하여 하나의 프로세서만 접근을 허용하여 상호배제를 만족하지만 세마포는 정수 형태의 counter값을 이용하여 공유 데이터 동시 접근이 가능하도록 함
    - 뮤텍스는 그 소유자만 해제할 수 있으나 세마포의 경우 그렇지 않다
  - CPU가 제공하는 특수 명령어 이용하는 방법과 XCHG를 이용하는 방법 존재
  - 공유 변수를 사용하는 크리티컬 섹션이 실행중이라는 사실을 별도의 락 변수에 기록해 두고 entry섹션과 exit섹션에서 이 값을 참조하여 실행
### 유한 버퍼 문제
  - 데이터를 생성하는 프로듀서 프로세스와 데이터를 소비하는 컨슈머 프로세스 간에 한정된 공유 버퍼를 사용하는 문제
  - 두 개의 세마포를 이용하여 Full은 버퍼에 보관되어 있는 데이터 아이템의 갯수를 의미하는데 초기값은 0이고, Empty는 버퍼의 빈 공간의 개수를 의미하는데 초기값은 전체 버퍼의 크기인 N이다.
### Reader-Writer문제
  - 공유 데이터의 일관성 유지에 있어 상호배제 형태로만 처리하면 지나치게 사용 제한함
  - 크리티컬 섹션에서 공유 데이터를 읽기만 하는 프로세스들과 쓰기만 하는 프로세스들로 구분되면 두개 이상이 동시에 실행되어도 일관성 유지에 문제 없음
### 모니터
### 컨디션 변수
  - 예약어에 의해 모니터 내에서 선언됨
  - 실행에 필요한 조건이 만족되지 않으면 만족될 때 까지 모니터 내에서 대기
  - 세마포와 차이
    - 세마포는 현재 상태를 나타내는 값을 가지고 있는 반면에 컨디션 변수는 이런 값이 존재하지 않음
    - 컨디션 변수는 무조건 대기상태로 들어가거나 레디상태로 변환됨
